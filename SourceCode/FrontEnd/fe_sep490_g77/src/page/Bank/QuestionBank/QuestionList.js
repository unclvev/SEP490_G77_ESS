import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import {
  Button,
  List,
  Card,
  Select,
  Input,
  Radio,
  message,
  Popconfirm,
  Upload,
  Tooltip,
} from "antd";
import { Typography, Space, Tag } from "antd";
import {
  EditOutlined,
  DownOutlined,
  UpOutlined,
  PlusOutlined,
} from "@ant-design/icons";
import {
  DeleteOutlined,
  DownloadOutlined,
  UploadOutlined,
} from "@ant-design/icons";
import {
  EditorState,
  ContentState,
  convertToRaw,
  Modifier,
  SelectionState,
} from "draft-js";
import parse from "html-react-parser";
import axios from "axios";
import { toast } from "react-toastify";
import { Editor } from "react-draft-wysiwyg";
import { stateToHTML } from "draft-js-export-html";
import "react-draft-wysiwyg/dist/react-draft-wysiwyg.css";
import { stateFromHTML } from "draft-js-import-html";
import "katex/dist/katex.min.css";
import { InlineMath, BlockMath } from "react-katex";
import { Modal } from "antd";
import { useRef } from "react";
import {
  getQuestions,
  getQuestionTypes,
  getLevels,
  createQuestion,
  updateQuestion,
  deleteQuestion,
  uploadImageBase64,
  importQuestionExcel,
  exportQuestionsExcel,
  deleteAllQuestionInSection,
} from "../../../services/api";

const { TextArea } = Input;
const { Option } = Select;
const QuestionList = () => {
  const { sectionId } = useParams();
  const [questions, setQuestions] = useState([]);
  const [questionTypes, setQuestionTypes] = useState([]);
  const [levels, setLevels] = useState([]);
  const [isEditing, setIsEditing] = useState(false);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const typeLabels = { 1: "Tr·∫Øc nghi·ªám", 2: "True/False", 3: "ƒêi·ªÅn k·∫øt qu·∫£" };
  const levelColors = { D·ªÖ: "green", "Trung b√¨nh": "gold", Kh√≥: "red" };
  const { Title, Paragraph, Text } = Typography;
  const [expandedQues, setExpandedQues] = useState(null);

  const [newQuestion, setNewQuestion] = useState({
    quescontent: "",
    typeId: null,
    modeid: null,
    secid: sectionId,
    solution: "",
    answers: [],
    correctAnswers: [""],
    imageUrl: "",
  });
  const [editorState, setEditorState] = useState(EditorState.createEmpty());
  // Th√™m v√†o c√°c state hi·ªán c√≥
  const [showMathInput, setShowMathInput] = useState(false);
  const [mathExpression, setMathExpression] = useState("");
  const [formulaListModalVisible, setFormulaListModalVisible] = useState(false);
  const [formulaList, setFormulaList] = useState([]); // Danh s√°ch c√¥ng th·ª©c [MATH:...]
  const [selectedFormulaIndex, setSelectedFormulaIndex] = useState(null);
  const [editingFormula, setEditingFormula] = useState("");
  const [editingAnswerIndex, setEditingAnswerIndex] = useState(null);
  const isMountedRef = useRef(true);
  useEffect(() => {
    fetchQuestions();
    fetchQuestionTypes();
    fetchLevels();
  }, [sectionId]);

  useEffect(() => {
    // Khi typeId thay ƒë·ªïi, c·∫≠p nh·∫≠t form theo lo·∫°i c√¢u h·ªèi
    if (newQuestion.typeId === 1) {
      // Tr·∫Øc nghi·ªám: 4 ƒë√°p √°n
      setNewQuestion((prev) => ({
        ...prev,
        answers: [
          ...(prev.answers.length ? prev.answers : []),
          "",
          "",
          "",
          "",
        ].slice(0, 4),
        correctAnswers: prev.correctAnswers.length
          ? [prev.correctAnswers[0]]
          : [""],
      }));
    } else if (newQuestion.typeId === 2) {
      // True/False: m·∫∑c ƒë·ªãnh l√† True,False
      setNewQuestion((prev) => ({
        ...prev,
        answers: ["True", "False"],
        correctAnswers:
          prev.correctAnswers.length === 4
            ? prev.correctAnswers
            : ["True", "True", "True", "True"],
      }));
    } else if (newQuestion.typeId === 3) {
      // ƒêi·ªÅn k·∫øt qu·∫£: kh√¥ng c·∫ßn answers, ch·ªâ c·∫ßn correctAnswers
      setNewQuestion((prev) => ({
        ...prev,
        answers: [],
        correctAnswers: prev.correctAnswers.length
          ? [prev.correctAnswers[0]]
          : [""],
      }));
    }
  }, [newQuestion.typeId]);

  useEffect(() => {
    if (currentQuestion && currentQuestion.quescontent) {
      const rawHTML = currentQuestion.quescontent;

      const cleanHTML = rawHTML
        .replace(
          /<span[^>]*class="katex-math"[^>]*data-formula="(.*?)"[^>]*>.*?<\/span>/g,
          (_, formula) => `[MATH:${formula}]`
        )
        .replace(/style="[^"]*"/g, "")
        .replace(/class="[^"]*"/g, "")
        .replace(/&nbsp;/g, " ");

      let contentState = stateFromHTML(cleanHTML);
      let newContent = contentState;

      const blocks = contentState.getBlockMap();
      blocks.forEach((block) => {
        const text = block.getText();
        const blockKey = block.getKey();
        const regex = /\[MATH:(.+?)\]/g;
        let match;
        while ((match = regex.exec(text)) !== null) {
          const formula = match[1];
          const start = match.index;
          const end = start + match[0].length;

          newContent = newContent.createEntity("KATEX", "IMMUTABLE", {
            formula,
          });
          const entityKey = newContent.getLastCreatedEntityKey();

          const selection = SelectionState.createEmpty(blockKey).merge({
            anchorOffset: start,
            focusOffset: end,
          });

          newContent = Modifier.replaceText(
            newContent,
            selection,
            `[MATH:${formula}]`,
            null,
            entityKey
          );
        }
      });

      setEditorState(EditorState.createWithContent(newContent));
    } else {
      setEditorState(EditorState.createEmpty());
    }
  }, [currentQuestion]);
  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const fetchQuestions = async () => {
    try {
      const response = await getQuestions(sectionId);
      setQuestions(response.data);
    } catch (error) {
      if (!isMountedRef.current) return;
      toast.error("L·ªói khi t·∫£i danh s√°ch c√¢u h·ªèi!");
    }
  };

  const fetchQuestionTypes = async () => {
    try {
      const response = await getQuestionTypes();
      setQuestionTypes(response.data);
    } catch (error) {
      if (!isMountedRef.current) return;
      toast.error("L·ªói khi t·∫£i danh s√°ch lo·∫°i c√¢u h·ªèi!");
    }
  };

  const fetchLevels = async () => {
    try {
      const response = await getLevels();
      setLevels(response.data);
    } catch (error) {
      if (!isMountedRef.current) return;
      toast.error("L·ªói khi t·∫£i danh s√°ch ƒë·ªô kh√≥!");
    }
  };

  const handleDeleteAll = () => {
    Modal.confirm({
      title: "X√≥a to√†n b·ªô c√¢u h·ªèi",
      content:
        "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ c√¢u h·ªèi trong section n√†y kh√¥ng?",
      okText: "X√≥a",
      okType: "danger",
      cancelText: "H·ªßy",
      onOk: async () => {
        try {
          await deleteAllQuestionInSection(sectionId);
          message.success("X√≥a t·∫•t c·∫£ c√¢u h·ªèi th√†nh c√¥ng!");
          // reload l·∫°i danh s√°ch
          fetchQuestions();
        } catch (error) {
          console.error(error);
          message.error("X√≥a th·∫•t b·∫°i, vui l√≤ng th·ª≠ l·∫°i.");
        }
      },
    });
  };

  const handleEdit = (question = null) => {
    setIsEditing(true);

    if (question) {
      setCurrentQuestion(question);

      // üîÅ L√†m s·∫°ch c√¥ng th·ª©c LaTeX
      const rawHTML = question.quescontent || "";

      const cleanHTML = rawHTML
        .replace(
          /<span[^>]*class="katex-math"[^>]*data-formula="(.*?)"[^>]*>.*?<\/span>/g,
          (_, formula) => `[MATH:${formula}]`
        )
        .replace(/style="[^"]*"/g, "")
        .replace(/class="[^"]*"/g, "")
        .replace(/&nbsp;/g, " ");

      let contentState = stateFromHTML(cleanHTML);
      let newContent = contentState;

      const blocks = contentState.getBlockMap();
      blocks.forEach((block) => {
        const text = block.getText();
        const blockKey = block.getKey();
        const regex = /\[MATH:(.+?)\]/g;
        let match;
        while ((match = regex.exec(text)) !== null) {
          const formula = match[1];
          const start = match.index;
          const end = start + match[0].length;

          newContent = newContent.createEntity("KATEX", "IMMUTABLE", {
            formula,
          });
          const entityKey = newContent.getLastCreatedEntityKey();

          const selection = SelectionState.createEmpty(blockKey).merge({
            anchorOffset: start,
            focusOffset: end,
          });

          newContent = Modifier.replaceText(
            newContent,
            selection,
            `[MATH:${formula}]`,
            null,
            entityKey
          );
        }
      });

      setEditorState(EditorState.createWithContent(newContent));

      // ‚úÖ T√πy lo·∫°i c√¢u h·ªèi
      if (question.typeId === 1) {
        setNewQuestion({
          quescontent: question.quescontent || "",
          typeId: question.typeId || null,
          modeid: question.modeid || null,
          secid: sectionId,
          solution: question.solution || "",
          answers: [...(question.answers || []), "", "", "", ""].slice(0, 4),
          correctAnswers: [question.correctAnswers[0] || ""],
          imageUrl: question.imageUrl || "",
        });
      } else if (question.typeId === 2) {
        setNewQuestion({
          quescontent: question.quescontent || "",
          typeId: question.typeId || null,
          modeid: question.modeid || null,
          secid: sectionId,
          solution: question.solution || "",
          answers: ["True", "False"],
          correctAnswers: [...question.correctAnswers], // ‚úÖ fix ·ªü ƒë√¢y
          imageUrl: question.imageUrl || "",
        });
      } else if (question.typeId === 3) {
        setNewQuestion({
          quescontent: question.quescontent || "",
          typeId: question.typeId || null,
          modeid: question.modeid || null,
          secid: sectionId,
          solution: question.solution || "",
          answers: [],
          correctAnswers: [question.correctAnswers[0] || ""],
          imageUrl: question.imageUrl || "",
        });
      }
    } else {
      // reset
      setCurrentQuestion(null);
      setEditorState(EditorState.createEmpty());
      setNewQuestion({
        quescontent: "",
        typeId: null,
        modeid: null,
        secid: sectionId,
        solution: "",
        answers: [],
        correctAnswers: [""],
        imageUrl: "",
      });
    }
  };

  const insertMathFormula = () => {
    if (!mathExpression.trim()) return;

    if (editingAnswerIndex !== null) {
      // We're editing an answer
      const updatedAnswers = [...newQuestion.answers];
      const formula = `[MATH:${mathExpression}]`;
      updatedAnswers[editingAnswerIndex] = formula;

      // If this is the selected correct answer, update correctAnswers too
      if (
        newQuestion.correctAnswers[0] ===
        newQuestion.answers[editingAnswerIndex]
      ) {
        setNewQuestion({
          ...newQuestion,
          answers: updatedAnswers,
          correctAnswers: [formula],
        });
      } else {
        setNewQuestion({
          ...newQuestion,
          answers: updatedAnswers,
        });
      }

      setEditingAnswerIndex(null);
    } else {
      // T·∫°o HTML ch·ª©a c√¥ng th·ª©c to√°n h·ªçc
      const mathHTML = `<span class="katex-math" data-formula="${mathExpression}">$$${mathExpression}$$</span>`;

      // Chuy·ªÉn HTML sang ContentState
      const contentState = editorState.getCurrentContent();
      const selection = editorState.getSelection();

      // Ch√®n m·ªôt ƒë·ªëi t∆∞·ª£ng KATEX entity
      const contentWithEntity = contentState.createEntity(
        "KATEX",
        "IMMUTABLE",
        { formula: mathExpression }
      );

      const entityKey = contentWithEntity.getLastCreatedEntityKey();

      // Ch√®n text v√† li√™n k·∫øt n√≥ v·ªõi entity
      const contentWithFormula = Modifier.insertText(
        contentWithEntity,
        selection,
        `[MATH:${mathExpression}]`, // Placeholder ƒë·ªÉ d·ªÖ nh·∫≠n bi·∫øt
        null,
        entityKey
      );

      // C·∫≠p nh·∫≠t EditorState
      const newEditorState = EditorState.push(
        editorState,
        contentWithFormula,
        "insert-characters"
      );

      setEditorState(newEditorState);

      // C·∫≠p nh·∫≠t quescontent
      setNewQuestion({
        ...newQuestion,
        quescontent: stateToHTML(contentWithFormula, {
          entityStyleFn: (entity) => {
            if (entity.getType() === "KATEX") {
              const formula = entity.getData().formula;
              return {
                element: "span",
                attributes: {
                  class: "katex-math",
                  "data-formula": formula,
                },
                style: {},
              };
            }
          },
        }),
      });
    }

    setMathExpression("");
    setShowMathInput(false);
  };

  const extractMathFormulas = () => {
    const regex = /\[MATH:(.+?)\]/g;
    const matches = [];
    const raw = newQuestion.quescontent;

    let match;
    while ((match = regex.exec(raw)) !== null) {
      matches.push(match[1]);
    }

    setFormulaList(matches);
    setFormulaListModalVisible(true);
  };
  const saveEditedFormula = () => {
    const updatedList = [...formulaList];
    updatedList[selectedFormulaIndex] = editingFormula;

    const raw = newQuestion.quescontent;
    const regex = /\[MATH:(.+?)\]/g;

    let currentIndex = -1;
    const updatedContent = raw.replace(regex, (_, formula) => {
      currentIndex++;
      return `[MATH:${updatedList[currentIndex]}]`;
    });

    // T·∫°o l·∫°i ContentState
    const newContentState = stateFromHTML(updatedContent);

    let finalContent = newContentState;
    const blocks = newContentState.getBlockMap();

    blocks.forEach((block) => {
      const text = block.getText();
      const blockKey = block.getKey();
      const mathRegex = /\[MATH:(.+?)\]/g;
      let match;

      while ((match = mathRegex.exec(text)) !== null) {
        const formula = match[1];
        const start = match.index;
        const end = start + match[0].length;

        finalContent = finalContent.createEntity("KATEX", "IMMUTABLE", {
          formula,
        });
        const entityKey = finalContent.getLastCreatedEntityKey();

        const selection = SelectionState.createEmpty(blockKey).merge({
          anchorOffset: start,
          focusOffset: end,
        });

        finalContent = Modifier.replaceText(
          finalContent,
          selection,
          `[MATH:${formula}]`,
          null,
          entityKey
        );
      }
    });

    setEditorState(EditorState.createWithContent(finalContent));

    // ‚úÖ Th√™m ƒëo·∫°n n√†y ƒë·ªÉ c·∫≠p nh·∫≠t l·∫°i quescontent
    const html = stateToHTML(finalContent, {
      entityStyleFn: (entity) => {
        if (entity.getType() === "KATEX") {
          const formula = entity.getData().formula;
          return {
            element: "span",
            attributes: {
              class: "katex-math",
              "data-formula": formula,
            },
            style: {},
          };
        }
      },
    });

    setNewQuestion((prev) => ({
      ...prev,
      quescontent: html,
    }));

    setFormulaList(updatedList);
    setFormulaListModalVisible(false);
    setSelectedFormulaIndex(null);
    setEditingFormula("");
  };

  const handleSave = async () => {
    if (
      !newQuestion.quescontent.trim() ||
      !newQuestion.typeId ||
      !newQuestion.modeid
    ) {
      toast.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin c√¢u h·ªèi!");
      return;
    }

    // Ki·ªÉm tra th√™m cho t·ª´ng lo·∫°i c√¢u h·ªèi
    if (newQuestion.typeId === 1) {
      // Tr·∫Øc nghi·ªám
      if (!newQuestion.correctAnswers[0]) {
        toast.warning("‚ö†Ô∏è Vui l√≤ng ch·ªçn ƒë√°p √°n ƒë√∫ng!");
        return;
      }
      const nonEmptyAnswers = newQuestion.answers.filter(
        (a) => a.trim() !== ""
      );
      if (nonEmptyAnswers.length < 2) {
        toast.warning("‚ö†Ô∏è C√¢u h·ªèi tr·∫Øc nghi·ªám c·∫ßn √≠t nh·∫•t 2 ƒë√°p √°n!");
        return;
      }
    } else if (newQuestion.typeId === 2) {
      // ‚úÖ True/False v·ªõi 4 √Ω
      if (newQuestion.correctAnswers.length !== 4) {
        toast.warning("‚ö†Ô∏è C√¢u h·ªèi True/False ph·∫£i c√≥ ƒë·ªß 4 √Ω!");
        return;
      }
    } else if (newQuestion.typeId === 3) {
      // ƒêi·ªÅn k·∫øt qu·∫£
      const answer = newQuestion.correctAnswers[0];
      if (
        !newQuestion.correctAnswers[0] ||
        newQuestion.correctAnswers[0].length !== 4
      ) {
        toast.warning("‚ö†Ô∏è ƒê√°p √°n ƒëi·ªÅn k·∫øt qu·∫£ ph·∫£i c√≥ ƒë√∫ng 4 k√Ω t·ª±!");
        return;
      }
      if (!/^[\d\-,]{4}$/.test(answer)) {
        toast.warning("‚ö†Ô∏è Ch·ªâ cho ph√©p nh·∫≠p s·ªë, d·∫•u - v√† d·∫•u , trong 4 k√Ω t·ª±!");
        return;
      }
    }

    try {
      const requestData = {
        quescontent: newQuestion.quescontent,
        typeId: newQuestion.typeId,
        modeid: newQuestion.modeid,
        secid: parseInt(sectionId),
        solution: newQuestion.solution,
        answers: newQuestion.typeId === 1 ? newQuestion.answers : [],
        correctAnswers:
          newQuestion.typeId === 2
            ? newQuestion.correctAnswers
            : [newQuestion.correctAnswers[0]],
        imageUrl: newQuestion.imageUrl,
      };

      let response;
      if (currentQuestion) {
        response = await updateQuestion(currentQuestion.quesid, requestData);
      } else {
        response = await createQuestion(requestData);
      }

      toast.success("‚úÖ L∆∞u c√¢u h·ªèi th√†nh c√¥ng!");
      setIsEditing(false);
      setNewQuestion({
        quescontent: "",
        typeId: null,
        modeid: null,
        secid: sectionId,
        solution: "",
        answers: [],
        correctAnswers: [""],
      });

      fetchQuestions();
    } catch (error) {
      toast.error(error.response?.data?.message || "‚ùå L·ªói khi l∆∞u c√¢u h·ªèi!");
    }
  };

  const handleDelete = async (quesid) => {
    try {
      await deleteQuestion(quesid);
      toast.success("X√≥a c√¢u h·ªèi th√†nh c√¥ng!");
      fetchQuestions();
    } catch (error) {
      if (
        error.response?.status === 403 ||
        error.response?.data?.message?.includes("Forbid")
      ) {
        toast.error("B·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a c√¢u h·ªèi");
      } else {
        toast.error("L·ªói khi x√≥a c√¢u h·ªèi!");
      }
    }
  };

  const handleExportExcel = async () => {
    try {
      const res = await exportQuestionsExcel(sectionId);
      const blob = new Blob([res.data], {
        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      });

      // T·∫°o t√™n file ƒë·∫πp v·ªõi ng√†y th√°ng nƒÉm v√† th·ªùi gian
      const date = new Date();
      const formattedDate = `${date.getFullYear()}${(date.getMonth() + 1)
        .toString()
        .padStart(2, "0")}${date.getDate().toString().padStart(2, "0")}`;
      const formattedTime = `${date
        .getHours()
        .toString()
        .padStart(2, "0")}${date.getMinutes().toString().padStart(2, "0")}${date
        .getSeconds()
        .toString()
        .padStart(2, "0")}`;

      const fileName = `expq_${formattedDate}_${formattedTime}_section_${sectionId}.xlsx`;

      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute("download", fileName);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Export Excel failed:", error);
    }
  };

  const handleImportExcel = async ({ file }) => {
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await importQuestionExcel(sectionId, formData);

      if (response.status === 200) {
        const { message, errors } = response.data;

        toast.success(message);

        // Ki·ªÉm tra v√† hi·ªÉn th·ªã l·ªói c·ª• th·ªÉ n·∫øu c√≥
        if (errors && errors.length > 0) {
          errors.forEach((errorDetail, index) => {
            toast.error(`L·ªói d√≤ng ${index + 1}: ${errorDetail}`, {
              autoClose: false, // kh√¥ng t·ª± ƒë·ªông t·∫Øt, ng∆∞·ªùi d√πng ph·∫£i ƒë√≥ng tay
            });
          });
        }

        await fetchQuestions();
      } else {
        toast.error("‚ùå Import kh√¥ng th√†nh c√¥ng, vui l√≤ng th·ª≠ l·∫°i!");
      }
    } catch (error) {
      toast.error(error.response?.data?.message || "‚ùå L·ªói khi import Excel!");

      if (error.response?.data?.errors) {
        error.response.data.errors.forEach((errorDetail, index) => {
          toast.error(`L·ªói d√≤ng ${index + 1}: ${errorDetail}`, {
            autoClose: false,
          });
        });
      }
    }
  };

  // Render c√°c tr∆∞·ªùng d·ªØ li·ªáu t√πy theo lo·∫°i c√¢u h·ªèi

  const renderQuestionFields = () => {
    switch (newQuestion.typeId) {
      case 1: // Tr·∫Øc nghi·ªám
        return (
          <div className="mb-4">
            <label className="font-semibold block mb-2">
              ƒê√°p √°n <span className="text-red-500">*</span>
            </label>

            <Radio.Group
              value={newQuestion.correctAnswers[0]}
              onChange={(e) =>
                setNewQuestion({
                  ...newQuestion,
                  correctAnswers: [e.target.value],
                })
              }
              className="w-full"
            >
              {newQuestion.answers.map((answer, index) => (
                <div key={index} className="flex items-center mb-2">
                  <div className="flex-grow mr-2 border rounded relative">
                    <Input
                      className="w-full pr-8"
                      placeholder={`ƒê√°p √°n ${index + 1}`}
                      value={answer}
                      onChange={(e) => {
                        const updatedAnswers = [...newQuestion.answers];
                        updatedAnswers[index] = e.target.value;

                        // N·∫øu ƒë√°p √°n ƒëang ƒë∆∞·ª£c ch·ªçn b·ªã thay ƒë·ªïi, c·∫≠p nh·∫≠t gi√° tr·ªã trong correctAnswers
                        if (
                          newQuestion.correctAnswers[0] ===
                          newQuestion.answers[index]
                        ) {
                          setNewQuestion({
                            ...newQuestion,
                            answers: updatedAnswers,
                            correctAnswers: [e.target.value],
                          });
                        } else {
                          setNewQuestion({
                            ...newQuestion,
                            answers: updatedAnswers,
                          });
                        }
                      }}
                    />
                    <Button
                      size="small"
                      className="absolute right-1 top-1/2 transform -translate-y-1/2"
                      onClick={() => {
                        // L∆∞u ƒë√°p √°n hi·ªán t·∫°i v√† hi·ªÉn th·ªã modal nh·∫≠p c√¥ng th·ª©c cho ƒë√°p √°n
                        setMathExpression("");
                        setShowMathInput(true);
                        // Th√™m bi·∫øn state ƒë·ªÉ bi·∫øt ƒëang s·ª≠a ƒë√°p √°n n√†o
                        setEditingAnswerIndex(index);
                      }}
                    >
                      Œ£
                    </Button>
                  </div>
                  <Radio value={answer}>
                    {/* Hi·ªÉn th·ªã preview LaTeX cho ƒë√°p √°n */}
                    {answer.includes("[MATH:")
                      ? renderQuestionWithMath(
                          answer.replace(
                            /\[MATH:(.*?)\]/g,
                            '<span class="katex-math" data-formula="$1">$$1</span>'
                          )
                        )
                      : "ƒê√∫ng"}
                  </Radio>
                </div>
              ))}
            </Radio.Group>
          </div>
        );

      case 2: // True/False
        return (
          <div className="mb-4">
            <label className="font-semibold block mb-2">
              Ch·ªçn True/False cho t·ª´ng √Ω (a‚Äìd){" "}
              <span className="text-red-500">*</span>
            </label>

            {["a", "b", "c", "d"].map((label, index) => (
              <div key={index} className="mb-2">
                <span className="mr-2">√Ω {label}:</span>
                <Radio.Group
                  value={newQuestion.correctAnswers[index]}
                  onChange={(e) => {
                    const updated = [...newQuestion.correctAnswers];
                    updated[index] = e.target.value;
                    setNewQuestion({ ...newQuestion, correctAnswers: updated });
                  }}
                  optionType="button"
                  buttonStyle="solid"
                >
                  <Radio.Button value="True">True</Radio.Button>
                  <Radio.Button value="False">False</Radio.Button>
                </Radio.Group>
              </div>
            ))}
          </div>
        );

      case 3: // ƒêi·ªÅn k·∫øt qu·∫£
        return (
          <div className="mb-4">
            <label className="font-semibold block mb-2">
              ƒê√°p √°n ƒë√∫ng (4 k√Ω t·ª±) <span className="text-red-500">*</span>
            </label>

            <Input
              placeholder="Nh·∫≠p ƒë√°p √°n (v√≠ d·ª•: 1234, -123, 0.12, ...)"
              value={newQuestion.correctAnswers[0]}
              onChange={(e) => {
                // Gi·ªõi h·∫°n ƒë·ªô d√†i l√† 4 k√Ω t·ª±
                const value = e.target.value.slice(0, 4);
                setNewQuestion({ ...newQuestion, correctAnswers: [value] });
              }}
              maxLength={4}
              className="w-full"
            />
            <div className="text-xs text-gray-500 mt-1">
              ƒê√°p √°n ph·∫£i c√≥ ƒë√∫ng 4 k√Ω t·ª± (bao g·ªìm c·∫£ d·∫•u, s·ªë).
            </div>
          </div>
        );

      default:
        return null;
    }
  };
  // Th√™m v√†o ph·∫ßn render c√¢u h·ªèi hi·ªán c√≥
  const renderQuestionWithMath = (htmlContent) => {
    const reactElement = parse(htmlContent, {
      replace: (domNode) => {
        if (domNode.attribs && domNode.attribs.class === "katex-math") {
          const formula = domNode.attribs["data-formula"];
          return <InlineMath math={formula} />;
        }
      },
    });

    return <div>{reactElement}</div>;
  };

  // üü¢ Hi·ªÉn th·ªã th√¥ng tin c√¢u h·ªèi trong danh s√°ch
  const renderQuestionContent = (question) => {
    switch (question.typeId) {
      case 1: // Tr·∫Øc nghi·ªám
        return (
          <>
            {question.answers && question.answers.length > 0 ? (
              <ul className="list-disc ml-6">
                {question.answers.map((answer, index) => (
                  <li key={index} className="py-1">
                    {answer.includes("[MATH:") ? (
                      <>
                        {renderQuestionWithMath(
                          answer.replace(
                            /\[MATH:(.*?)\]/g,
                            '<span class="katex-math" data-formula="$1">$$1</span>'
                          )
                        )}
                      </>
                    ) : (
                      answer
                    )}
                    {question.correctAnswers.includes(answer) && (
                      <span className="text-green-600 font-semibold"> ‚úì</span>
                    )}
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-red-500 font-semibold">
                ‚ö†Ô∏è C·∫ßn c√≥ √≠t nh·∫•t 1 ƒë√°p √°n!
              </p>
            )}
          </>
        );

      case 2: // True/False
        return (
          <>
            {question.correctAnswers && question.correctAnswers.length === 4 ? (
              <ul className="list-none ml-2">
                {question.correctAnswers.map((ans, index) => (
                  <li key={index} className="py-1">
                    <strong className="mr-1">
                      {String.fromCharCode(65 + index)}.
                    </strong>
                    <span
                      className={`px-2 py-0.5 rounded text-white text-sm font-medium ${
                        ans.toLowerCase() === "true"
                          ? "bg-green-500"
                          : "bg-red-500"
                      }`}
                    >
                      {ans}
                    </span>
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-red-500 font-semibold">
                ‚ö†Ô∏è C·∫ßn ƒë√∫ng 4 ƒë√°p √°n True/False!
              </p>
            )}
          </>
        );

      case 3: // ƒêi·ªÅn k·∫øt qu·∫£
        return (
          <>
            {question.correctAnswers &&
            question.correctAnswers[0]?.length === 4 ? (
              <p className="font-semibold">
                ƒê√°p √°n ƒë√∫ng:{" "}
                <span className="bg-blue-100 px-3 py-1 rounded ml-2">
                  {question.correctAnswers[0]}
                </span>
              </p>
            ) : (
              <p className="text-red-500 font-semibold">
                ‚ö†Ô∏è ƒê√°p √°n ƒë√∫ng ph·∫£i ƒë·ªß 4 k√Ω t·ª±!
              </p>
            )}
          </>
        );

      default:
        return (
          <p className="text-red-500 font-semibold">
            ‚ö†Ô∏è Lo·∫°i c√¢u h·ªèi kh√¥ng x√°c ƒë·ªãnh!
          </p>
        );
    }
  };
  // Image upload component

  // Th√™m h√†m renderMathInput
  const renderMathInput = () => {
    if (!showMathInput) return null;

    return (
      <div className="math-input-container border p-4 mb-4 bg-gray-50 rounded">
        <h4 className="font-semibold mb-2">
          {editingAnswerIndex !== null
            ? `Nh·∫≠p c√¥ng th·ª©c to√°n h·ªçc cho ƒë√°p √°n ${editingAnswerIndex + 1}`
            : "Nh·∫≠p c√¥ng th·ª©c to√°n h·ªçc"}
        </h4>
        <p className="text-sm text-gray-600 mb-2">
          S·ª≠ d·ª•ng c√∫ ph√°p LaTeX. V√≠ d·ª•: <code>{"\\frac{a}{b}"}</code>,{" "}
          <code>{"\\sqrt{x}"}</code>, <code>{"x^2"}</code>
        </p>

        <div className="flex flex-wrap gap-2 mb-3">
          <Button
            size="small"
            onClick={() => setMathExpression("\\frac{a}{b}")}
          >
            Ph√¢n s·ªë (a/b)
          </Button>
          <Button size="small" onClick={() => setMathExpression("\\sqrt{x}")}>
            CƒÉn b·∫≠c 2
          </Button>
          <Button size="small" onClick={() => setMathExpression("x^2")}>
            L≈©y th·ª´a (x¬≤)
          </Button>
          <Button
            size="small"
            onClick={() => setMathExpression("\\int_{a}^{b} f(x) dx")}
          >
            T√≠ch ph√¢n
          </Button>
        </div>

        <div className="flex">
          <Input
            value={mathExpression}
            onChange={(e) => setMathExpression(e.target.value)}
            placeholder="Nh·∫≠p c√¥ng th·ª©c LaTeX"
            className="flex-grow mr-2"
          />
          <Button type="primary" onClick={insertMathFormula}>
            Ch√®n
          </Button>
          <Button
            className="ml-2"
            onClick={() => {
              setShowMathInput(false);
              setEditingAnswerIndex(null);
            }}
          >
            H·ªßy
          </Button>
        </div>

        {mathExpression && (
          <div className="mt-3 p-2 border rounded bg-white">
            <p className="text-sm mb-1">Xem tr∆∞·ªõc:</p>
            <BlockMath math={mathExpression} />
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="p-0 bg-gray-100 min-h-screen grid grid-cols-2 gap-4">
      {/* DANH S√ÅCH C√ÇU H·ªéI */}
      <div
        className="bg-white p-6 shadow-md rounded relative" // ‚Üê th√™m `relative`
        style={{ height: "100vh", overflowY: "auto" }}
      >
        {/* Sticky header */}
        <div
          className="sticky top-0 bg-white p-2 shadow flex items-center justify-between space-x-2"
          style={{ left: 0, right: 0, zIndex: 5 }} // ƒë·∫£m b·∫£o full-width trong khung cha
        >
          {/* Ti√™u ƒë·ªÅ */}
          <h1 className="text-xl font-bold m-0">Danh S√°ch C√¢u H·ªèi</h1>

          {/* Nh√≥m n√∫t icon nh·ªè */}
          <div className="flex items-center space-x-1">
            {/* Th√™m c√¢u h·ªèi */}
            <Tooltip title="Th√™m c√¢u h·ªèi">
              <Button
                type="text"
                icon={<PlusOutlined />}
                size="small"
                onClick={() => handleEdit()}
              />
            </Tooltip>

            <Tooltip title="X√≥a t·∫•t c·∫£">
              <Button
                type="text"
                icon={<DeleteOutlined />}
                size="small"
                onClick={() => handleDeleteAll()}
              />
            </Tooltip>

            {/* T·∫£i File M·∫´u */}
            <Tooltip title="T·∫£i file m·∫´u">
              <Button
                type="text"
                icon={<DownloadOutlined />}
                size="small"
                onClick={handleExportExcel}
              />
            </Tooltip>

            {/* Import Excel */}
            <Tooltip title="Import Excel">
              <Upload customRequest={handleImportExcel} showUploadList={false}>
                <Button type="text" icon={<UploadOutlined />} size="small" />
              </Upload>
            </Tooltip>
          </div>
        </div>

        <List
          itemLayout="vertical"
          dataSource={questions}
          renderItem={(question, index) => {
            const isOpen = expandedQues === question.quesid;
            const levelName =
              levels.find((l) => l.levelId === question.modeid)?.levelName ||
              "N/A";

            return (
              <List.Item key={question.quesid}>
                <Card
                  style={{ marginBottom: 16, borderRadius: 8, zIndex: 4 }}
                  bodyStyle={{ padding: 16 }}
                >
                  <Space
                    align="center"
                    justify="space-between"
                    style={{ width: "100%" }}
                  >
                    <Title level={5} style={{ margin: 0 }}>
                      C√¢u {index + 1}
                    </Title>
                    <Space>
                      <Tag color="blue">{typeLabels[question.typeId]}</Tag>
                      <Tag color={levelColors[levelName] || "default"}>
                        {levelName}
                      </Tag>
                      <Button
                        type="text"
                        icon={<EditOutlined />}
                        onClick={() => handleEdit(question)}
                      />
                      <Popconfirm
                        title="B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a?"
                        onConfirm={() => handleDelete(question.quesid)}
                        okText="X√≥a"
                        cancelText="H·ªßy"
                      >
                        <Button type="text" danger icon={<DeleteOutlined />} />
                      </Popconfirm>
                    </Space>
                  </Space>

                  <Paragraph style={{ margin: "16px 0" }}>
                    {renderQuestionWithMath(question.quescontent)}
                  </Paragraph>

                  {question.imageUrl && (
                    <div className="mt-3 border rounded p-2 bg-gray-50">
                      <img
                        src={
                          question.imageUrl.startsWith("http")
                            ? question.imageUrl
                            : `https://localhost:7052${question.imageUrl}`
                        }
                        alt="Question image"
                        className="max-w-full max-h-64 object-contain"
                      />
                    </div>
                  )}

                  <Space
                    direction="vertical"
                    style={{ width: "100%", marginTop: 16 }}
                    size="small"
                  >
                    {renderQuestionContent(question)}
                  </Space>

                  <div style={{ marginTop: 12 }}>
                    <Button
                      type="link"
                      icon={isOpen ? <UpOutlined /> : <DownOutlined />}
                      onClick={() =>
                        setExpandedQues(isOpen ? null : question.quesid)
                      }
                    >
                      {isOpen ? "·∫®n gi·∫£i th√≠ch" : "Xem gi·∫£i th√≠ch"}
                    </Button>
                    {isOpen && question.solution && (
                      <Paragraph
                        type="secondary"
                        style={{
                          marginTop: 8,
                          paddingLeft: 16,
                          borderLeft: "2px solid #f0f0f0",
                        }}
                      >
                        {question.solution}
                      </Paragraph>
                    )}
                  </div>
                </Card>
              </List.Item>
            );
          }}
        />
      </div>

      {/* FORM TH√äM/S·ª¨A C√ÇU H·ªéI */}
      {isEditing && (
        <div className="bg-white p-6 shadow-md rounded">
          <h2 className="text-2xl font-bold mb-4">
            {currentQuestion ? "Ch·ªânh S·ª≠a C√¢u H·ªèi" : "Th√™m C√¢u H·ªèi"}
          </h2>

          <label className="font-semibold">
            Lo·∫°i c√¢u h·ªèi <span className="text-red-500">*</span>
          </label>

          <Select
            className="w-full mb-4"
            placeholder="Ch·ªçn lo·∫°i c√¢u h·ªèi"
            value={newQuestion.typeId ?? undefined}
            onChange={(value) =>
              setNewQuestion({
                ...newQuestion,
                typeId: value,
                // Reset other fields when changing question type
                answers: [],
                correctAnswers: [""],
              })
            }
          >
            {questionTypes.map((type) => (
              <Option key={type.typeId} value={type.typeId}>
                {type.typeName}
              </Option>
            ))}
          </Select>

          <label className="font-semibold">
            ƒê·ªô kh√≥ <span className="text-red-500">*</span>
          </label>

          <Select
            className="w-full mb-4"
            placeholder="Ch·ªçn ƒë·ªô kh√≥"
            value={newQuestion.modeid || undefined}
            onChange={(value) =>
              setNewQuestion({ ...newQuestion, modeid: value })
            }
          >
            {levels.map((level) => (
              <Option key={level.levelId} value={level.levelId}>
                {level.levelName}
              </Option>
            ))}
          </Select>

          <label className="font-semibold">
            N·ªôi dung c√¢u h·ªèi <span className="text-red-500">*</span>
          </label>

          <div className="mb-2">
            <Button
              type="primary"
              size="small"
              onClick={() => setShowMathInput(!showMathInput)}
              className="mr-2"
            >
              {showMathInput ? "·∫®n c√¥ng th·ª©c" : "Th√™m c√¥ng th·ª©c to√°n h·ªçc"}
            </Button>
            <Button size="small" type="dashed" onClick={extractMathFormulas}>
              Ch·ªânh s·ª≠a c√¥ng th·ª©c to√°n h·ªçc
            </Button>
          </div>

          {renderMathInput()}

          <Editor
            editorState={editorState}
            onEditorStateChange={(state) => {
              setEditorState(state);
              const content = state.getCurrentContent();
              setNewQuestion({
                ...newQuestion,
                quescontent: stateToHTML(content, {
                  entityStyleFn: (entity) => {
                    if (entity.get("type") === "KATEX") {
                      return {
                        element: "span",
                        attributes: {
                          class: "katex-math",
                          "data-formula": entity.getData().formula,
                        },
                      };
                    }
                  },
                }),
              });
            }}
            wrapperClassName="mb-4 border border-gray-200"
            editorClassName="p-2 bg-white min-h-[200px]"
            toolbar={{
              options: ["inline", "list", "link", "history"],
              inline: { inDropdown: false },
              list: { inDropdown: true },
              link: { inDropdown: false },
              history: { inDropdown: false },
            }}
          />
          <Modal
            title="Ch·ªânh s·ª≠a c√¥ng th·ª©c to√°n h·ªçc"
            open={formulaListModalVisible}
            onCancel={() => setFormulaListModalVisible(false)}
            footer={null}
          >
            {formulaList.length === 0 ? (
              <p>Kh√¥ng t√¨m th·∫•y c√¥ng th·ª©c n√†o.</p>
            ) : selectedFormulaIndex === null ? (
              <>
                <p>Ch·ªçn c√¥ng th·ª©c ƒë·ªÉ ch·ªânh s·ª≠a:</p>
                <ul className="list-disc pl-4">
                  {formulaList.map((formula, idx) => (
                    <li key={idx} className="mb-2">
                      <code className="bg-gray-100 p-1 rounded">{formula}</code>
                      <Button
                        size="small"
                        className="ml-2"
                        onClick={() => {
                          setSelectedFormulaIndex(idx);
                          setEditingFormula(formula);
                        }}
                      >
                        Ch·ªânh s·ª≠a
                      </Button>
                    </li>
                  ))}
                </ul>
              </>
            ) : (
              <>
                <p className="mb-2">C·∫≠p nh·∫≠t c√¥ng th·ª©c LaTeX:</p>
                <Input.TextArea
                  rows={2}
                  value={editingFormula}
                  onChange={(e) => setEditingFormula(e.target.value)}
                />
                <div className="flex justify-end mt-3 gap-2">
                  <Button
                    onClick={() => {
                      setSelectedFormulaIndex(null);
                      setEditingFormula("");
                    }}
                  >
                    Quay l·∫°i
                  </Button>
                  <Button type="primary" onClick={saveEditedFormula}>
                    L∆∞u
                  </Button>
                </div>
              </>
            )}
          </Modal>

          {/* Fields specific to question type */}
          {renderQuestionFields()}
          <div className="mb-4">
            <label className="font-semibold block mb-2">
              H√¨nh ·∫£nh (kh√¥ng b·∫Øt bu·ªôc)
            </label>
            <Upload
              name="image"
              listType="picture-card"
              showUploadList={false}
              beforeUpload={(file) => {
                const isImage = file.type.startsWith("image/");
                const isLt5M = file.size / 1024 / 1024 < 5;

                if (!isImage) {
                  message.error("Ch·ªâ ch·∫•p nh·∫≠n file h√¨nh ·∫£nh!");
                  return Upload.LIST_IGNORE;
                }

                if (!isLt5M) {
                  message.error("·∫¢nh ph·∫£i nh·ªè h∆°n 5MB!");
                  return Upload.LIST_IGNORE;
                }

                return true;
              }}
              customRequest={async ({ file }) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);

                reader.onload = async () => {
                  try {
                    const base64Image = reader.result;
                    const response = await uploadImageBase64(base64Image);

                    let imageUrl = response.data.imageUrl;
                    if (imageUrl && imageUrl.startsWith("/")) {
                      imageUrl = `http://localhost:7052${imageUrl}`;
                    }
                    setNewQuestion((prev) => ({
                      ...prev,
                      imageUrl,
                    }));

                    toast.success("T·∫£i ·∫£nh l√™n th√†nh c√¥ng!");
                  } catch (error) {
                    toast.error("L·ªói khi t·∫£i ·∫£nh base64 l√™n!");
                    console.error(error);
                  }
                };
              }}
            >
              {newQuestion.imageUrl ? (
                <div className="relative w-full h-full">
                  <img
                    src={newQuestion.imageUrl}
                    alt="Uploaded"
                    className="w-full h-full object-cover"
                  />
                  <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                    <Button
                      type="primary"
                      icon={<UploadOutlined />}
                      className="mr-2"
                    >
                      Thay ƒë·ªïi
                    </Button>
                    <Button
                      danger
                      icon={<DeleteOutlined />}
                      onClick={(e) => {
                        e.stopPropagation();
                        setNewQuestion((prev) => ({ ...prev, imageUrl: "" }));
                      }}
                    />
                  </div>
                </div>
              ) : (
                <div>
                  <UploadOutlined />
                  <div className="mt-2">T·∫£i ·∫£nh l√™n</div>
                </div>
              )}
            </Upload>

            {/* Hi·ªÉn th·ªã ·∫£nh sau khi upload */}
            {newQuestion.imageUrl && (
              <div className="mt-2">
                <img
                  src={newQuestion.imageUrl}
                  alt="Preview"
                  className="max-h-64 object-contain border rounded"
                />
              </div>
            )}

            {newQuestion.imageUrl && (
              <div className="mt-2">
                <a
                  href={newQuestion.imageUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-500 hover:underline"
                >
                  {newQuestion.imageUrl.split("/").pop()}
                </a>
              </div>
            )}
          </div>
          {/* Solution field for all question types */}
          <label className="font-semibold">Gi·∫£i th√≠ch</label>
          <TextArea
            rows={3}
            className="mb-4"
            placeholder="Nh·∫≠p gi·∫£i th√≠ch cho c√¢u h·ªèi (kh√¥ng b·∫Øt bu·ªôc)"
            value={newQuestion.solution}
            onChange={(e) =>
              setNewQuestion({ ...newQuestion, solution: e.target.value })
            }
          />

          <div className="flex gap-2">
            <Button type="primary" className="flex-grow" onClick={handleSave}>
              L∆∞u C√¢u H·ªèi
            </Button>
            <Button onClick={() => setIsEditing(false)}>H·ªßy</Button>
          </div>
        </div>
      )}
    </div>
  );
};

export default QuestionList;
